//
//  QFactory.cpp
//  q
//
//  Created by Tomer Doron on 4/30/13.
//  Copyright (c) 2013 Tomer Doron. All rights reserved.
//

// config.h is generated by autoreconf / configure
#include "../../config.h"

#include "QFactory.h"

#include "../3rd-party/json/json.h"
#include "Logger.h"

//#include "../backends/TransientQ.h"
//#include "../backends/BerkeleyQ.h"
//#ifdef DB_CXX_HEADER
//    #include "../backends/BerkeleyQ.h"
//#endif
//#include "../backends/KyotoCabinetQ.h"

#include "../backends/LMDBQ.h"
#include "../backends/RedisQ.h"

namespace Q
{    
    typedef enum QType
    {
        QTUndefined,
        //QTTransient,
        //QTBerkeley,
        //QTKyotoCabinet,
        QTLMDB,
        QTRedis
    } QType;

    static Json::Value parse_config(const string& configuration);
    static QType parse_driver(const string& driver);
    static bool iequals(const string& a, const string& b);

    bool QFactory::createQ(Q** qp, const string& configuration)
    {
        try
        {
            Json::Value json_config = !configuration.empty() ? parse_config(configuration) : Json::Value();
            string driver = json_config.get("driver", "").asString();
            QType q_type = parse_driver(driver);
            
            switch (q_type)
            {
                case QTUndefined:
                //case QTTransient:
                //    *qp = new TransientQ(configuration);
                //    break;
//#ifdef DB_CXX_HEADER
//                case QTBerkeley:
//                    *qp = new BerkeleyQ(json_config);
//                    break;
//#endif
//                case QTKyotoCabinet:
//                    *qp = new KyotoCabinetQ(json_config);
//                    break;
                case QTLMDB:
                    *qp = new LMDBQ(json_config);
                    break;
                case QTRedis:
                    *qp = new RedisQ(json_config);
                    break;
                default:
                    throw QException("unknown driver");
                    break;
            }
        }
        catch (exception& e)
        {
            *qp = NULL;        
            q_error("q initialization error. %s", e.what());
        }
        catch (...)
        {
            *qp = NULL;
            q_error("unknown q initialization error");
        }
        return (NULL != *qp);
    }

    QType parse_driver(const string& driver)
    {
        if (driver.empty()) return QTUndefined;
        //if (iequals(driver, "transient")) return QTTransient;
        //if (iequals(driver, "berkeley")) return QTBerkeley;
        //if (iequals(driver, "kc")) return QTKyotoCabinet;
        if (iequals(driver, "lmdb")) return QTLMDB;
        if (iequals(driver, "redis")) return QTRedis;
        return QTUndefined;
    }

    Json::Value parse_config(const string& configuration)
    {
        Json::Value root;
        Json::Reader reader;
        bool result = reader.parse(configuration, root);
        if (!result) throw QException("failed parsing configuration json. " + reader.getFormatedErrorMessages());
        return root;
    }

    bool iequals(const string& a, const string& b)
    {
        unsigned long sz = a.size();
        if (b.size() != sz)
            return false;
        for (unsigned int i = 0; i < sz; ++i)
            if (tolower(a[i]) != tolower(b[i]))
                return false;
        return true;
    }
}